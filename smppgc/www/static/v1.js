// This file is generated by gen_js.sh (do not modify)
/* == smppgc/js/mkels.js == */
function mksender(sender, parent_el) {
  let special = sender == "system";
  let sender_el = document.createElement("span");
  if (special){
    sender_el.classList.add("special");
  }
  sender_el.classList.add("user");
  sender_el.innerText=sender;
  parent_el.appendChild(sender_el);
}
function mkspace(parent_el) {
  let space = document.createElement("div");
  space.classList.add("space");
  parent_el.appendChild(space);
}

function mktime(time, parent_el) {
  if (time == undefined){ return; }
  let time_el = document.createElement("small");
  time_el.classList.add("message_timestamp")
  time_el.innerText = time.toLocaleString(undefined, {
    dateStyle:"short",
    timeStyle:"short",
  });
  parent_el.appendChild(time_el);
}
/* == smppgc/js/ui.js == */
const leavebtn = document.getElementById("leavebtn");
const sendbtn = document.getElementById("sendbtn");
const sendinput = document.getElementById("send-input");
const mesgs = document.getElementById("mesgs");
const pending_mesgs = document.getElementById("pending-mesgs");
const username_field = document.getElementById("name-input");
const connectbtn = document.getElementById("connectbtn");
const constatus = document.getElementById("connection-status");
const err_mesg = document.getElementById("err-mesg");

const login_popup=document.getElementById("login");

const STICKERS=["404", "arch", "tux", "smpp", "gc"]; // avail stickers (used to prevent unneeded 404s to the server)

const STATUS_DISCONNECTED=0;
const STATUS_CONNECTING=1;
const STATUS_CONNECTED=2;

let cur_status = STATUS_DISCONNECTED;

function ui_show_login(show) {
  if (show){
    login_popup.style="";
    sendinput.disabled=true;
  }else{
    login_popup.style="display:none"; sendinput.disabled=false;
  }
}


function ui_error(error) {
  err_mesg.innerText=error;
}
function ui_set_status(value){
  switch(value){
    case STATUS_CONNECTED:
      ui_show_login(false);
      constatus.style="display:none";
      if (cur_status != value){
        sendinput.focus();
        ui_clear_chat();
      }
      break;
    case STATUS_CONNECTING:
      constatus.style="";
      ui_show_login(false);
      break;

    case STATUS_DISCONNECTED:
      ui_show_login(true);
      constatus.style="display:none";
      break;
  }
  cur_status = value;
}

function ui_set_name(name) {
  username_field.value = name;
}

function ui_get_name() {
  let local_name = username_field.value;
  if (username_field.value == ""){
    local_name = username_field.dataset.default_username;
  }
  return local_name;
}

// Read the input message and clear it
function ui_get_input() {
  return sendinput.value.trim();
}
function ui_clear_input() {
  sendinput.value="";
  sendinput.parentNode.dataset.replicatedValue="";
}

function ui_clear_chat() {
  mesgs.innerHTML="";
  pending_mesgs.innerHTML="";
}

function ui_add_pending(message) {
  let msg = document.createElement("div");
  msg.innerText=message;
  pending_mesgs.appendChild(msg);
}

function ui_remove_pending(message) {
  let mesgs = pending_mesgs.childNodes;
  for (let i=0; i<mesgs.length; i++){
    let mesg = mesgs[i];
    if (mesg.innerText == message){
      pending_mesgs.removeChild(mesg);
      break;
    }
  }
}

function mkspan(innerText, parent_el){
    let span = document.createElement("span");
    span.innerText=innerText;
    parent_el.appendChild(span);
}
function mka(link, parent_el) {
    let a = document.createElement("a");
    a.href=link;
    a.target="_blank";
    a.innerText=link;
    parent_el.appendChild(a);
}
function mksticker(name, parent_el) {
    let img = document.createElement("img");
    img.width=50;
    img.dataset.sticker=name
    img.src=ROOT_URL+"/static/stickies/"+name+".webp";
    parent_el.appendChild(img);
}


// convert urls into html tags
function format_urls(message, parent_el) {
  const find_link_regex = /(https?:\/\/[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b[-a-zA-Z0-9()@:%_\+.~#?&//=]*)|(:[a-z0-9_-]{3,10}:)/g;

  const matches = message.matchAll(find_link_regex);
  let last_index = 0;
  for (const match of matches){
    let skip=false;
    mkspan(message.substring(last_index, match.index), parent_el);

    if (match[1] !== undefined){
      mka(match[1], parent_el)
    }
    if (match[2] !== undefined){
      let name = match[2].substring(1, match[2].length-1);
      if (STICKERS.includes(name)){
        mksticker(name, parent_el);
      }else{
        skip=true;
      }
    }
    if (!skip){
      last_index = match.index+match[0].length;
    }

  }
  mkspan(message.substring(last_index), parent_el);
}


async function ui_add_message(message, sender, timestamp, scroll=false){
  let top_el = document.createElement("div");
  top_el.classList.add("message_top");
  mksender(sender, top_el);
  mkspace(top_el);
  mktime(timestamp, top_el);

  let content_el = document.createElement("div");
  content_el.classList.add("content");
  format_urls(message, content_el);

  let user_content_el=document.createElement("div");
  user_content_el.classList.add("user_content");
  user_content_el.appendChild(top_el);
  user_content_el.appendChild(content_el);
  let msg_el = document.createElement("div");
  msg_el.innerHTML=`
<svg class="driehoek_bubble" viewBox="0 0 8 13" height="13" width="8" preserveAspectRatio="xMidYMid meet" class="" version="1.1" x="0px" y="0px" enable-background="new 0 0 8 13"><path fill="currentColor" d="M1.5,2.5L8,11.2V0L2.8,0C1,0,0.5,1.2,1.5,2.6z"></path></svg>`
  msg_el.appendChild(user_content_el);
  msg_el.classList.add("message");
  msg_el.dataset.username=sender;

  let should_scroll = Math.abs(mesgs.scrollHeight - mesgs.clientHeight - mesgs.scrollTop) <= 1 || scroll;
  mesgs.appendChild(msg_el);
  console.log("should scroll: "+should_scroll)
  if (should_scroll){
    msg_el.scrollIntoView();
  }
}

/* == smppgc/js/ws.js == */
const CLOSED=3;
const SUBID_SETUP=0;
const SUBID_USERJOIN=1;
const KEY_LENGTH=33;

class Reader{
  #dv;
  #index;
  constructor(dv){
    this.dv = dv;
    this.index = 0;
    this.tdecoder = new TextDecoder();
  }

  getString(offset, length) {
    let len = typeof length == 'number' ? length : this.dv.byteLength-(this.index+offset);
    let dv = new DataView(this.dv.buffer, this.index+offset, len);
    this.index+=len;
    return this.tdecoder.decode(dv);
  };

  getUint8(offset=0){
    let out = this.dv.getUint8(this.index+offset, false);
    this.index+=1;
    return out;
  }
  getUint16(offset=0){
    let out = this.dv.getUint16(this.index+offset, false);
    this.index+=2;
    return out;
  }
  getUint32(offset=0){
    let out = this.dv.getUint32(this.index+offset, false);
    this.index+=4;
    return out;
  }

  getDate(offset=0){
    return new Date((this.getUint32(offset)*1000*60))
  }

  end(){
    return this.index >= this.dv.byteLength;
  }
}

class SocketMgr{
  on_message;
  on_leave;
  on_join;
  on_keychange;

  #local_id;
  #users;
  #user_wants_leave;

  constructor(){
    this.users={};
  }

  #on_special_message(sub_id, reader){
    switch(sub_id){
      case SUBID_SETUP:
        this.on_join();
        this.local_id = reader.getUint16();
        this.local_key = reader.getString(0, KEY_LENGTH);
        this.on_keychange(this.local_key);

        let client_count = reader.getUint16();
        for (let i = 0; i < client_count; i++){
          let id = reader.getUint16();
          let name_length = reader.getUint8();
          let username = reader.getString(0, name_length);
          this.users[id]=username;
          console.log("(hist_user) "+username+" ("+id+")")
        }

        while(!reader.end()){
          let timestamp = reader.getDate();
          let username_length=reader.getUint8();
          let username = reader.getString(0, username_length);
          let mesg_length=reader.getUint8();
          let message = reader.getString(0, mesg_length);
          this.on_message(this.local_id, -1, username, timestamp, message);
        }

        console.log("Setup packet "+this.local_id+" "+this.local_key);
        break;
      case SUBID_USERJOIN:
        let id = reader.getUint16(0);
        let username = reader.getString(0)
        console.log("user join: "+username+" ("+id+")");
        this.users[id] = username;
        break;
      default:
        console.error("PROTOCOL_ERROR: Invalid subid ("+sub_id+") packet recieved");
        break;
    }

  }

  async join(key, username){
    this.user_wants_leave=false;
    if (this.ws !== undefined){
      await this.ws.close();
    }
    let encoded_username = encodeURIComponent(username);
    let query=`username=${encoded_username}`;
    if (key !== undefined && key !== null && key !== ""){
      query+="&key="+key;
    }
    let fullurl = WEBSOCKET_URL+"?"+query;
    console.log("creating socket: "+fullurl);
    this.ws = new WebSocket(fullurl);
    this.ws.binaryType = "arraybuffer";

    this.ws.onclose = async (e) => {
      this.users={};
      let reason = e.reason;
      if (!e.reason || e.reason.startsWith("INT:")){
        if (e.reason) {
          console.error("Internal Error: "+e.reason);
        }else{
          console.error("Reason empty");
          console.error(e);
        }
        reason="Onverwachte fout.";
      }
      this.on_leave(e.code, reason, this.user_wants_leave);
    }

    this.ws.onmessage = async (e) =>{
      let data = e.data;
      if (data instanceof ArrayBuffer){
        let reader = new Reader(new DataView(data))
        const sender_id = reader.getUint16();
        if (sender_id == 0){ // user 0 is special message
          let sub_id = reader.getUint8();
          this.#on_special_message(sub_id, reader);
        }else{
          const timestamp = reader.getDate();
          let message = reader.getString(0);
          let sender_username = this.users[sender_id];
          let me = this.local_id == sender_id;
          if (me){
            sender_username = username;
          }
          this.on_message(me, sender_id, sender_username, timestamp, message);
        }
      }
    };
  }

  async send(message){
    if (this.ws.readyState !== WebSocket.OPEN){
      return false;
    }
    if (this.ws.bufferedAmount > 2){
      return false;
    }
    await this.ws.send(message);
    return true;
  }

  async leave(){
    this.user_wants_leave=true;
    await this.ws.close(1000, "Dag dag ik ga je missen. xxx");
  }

}
/* == smppgc/js/index.js == */
let importance_filter=["ldev"];

function update_importance_filter() {
  let css = "";
  let css_driehoek="";
  for (let i=0; i < importance_filter.length; i++){
    let name = importance_filter[i];
    css+=".message[data-username=\""+name+"\"]"
    css_driehoek+=".message[data-username=\""+name+"\"] > .driehoek_bubble";
    if (i !== importance_filter.length-1){
      css+=",";
      css_driehoek+=",";
    }
  }
  css+=`{
  align-self:end;
  text-align:right;
  border-top-left-radius: 10px;
  border-top-right-radius: 0px;
}`;
  css_driehoek+=`{
  right:-18px;
  left:unset;
  order: 2;
  transform: rotateY(180deg);
}`;
  document.getElementById("importance_filter").innerText = css+"\n"+css_driehoek;
}

let socketmgr = new SocketMgr();


socketmgr.on_join = () => {
  ui_set_status(STATUS_CONNECTED);
}

let last_retry = 0;

socketmgr.on_leave = (code, reason, user_wants_leave) => {
  console.log("leaving.. "+code);
  ui_set_status(STATUS_DISCONNECTED);
  if (user_wants_leave){
    return;
  }
  switch (code) {
    case 1000: // Normal Closure
      return;
    case 1006: // Abnormal Closure
      let now = Date.now();
      if (last_retry == 0 || now-last_retry > 10_000){ // join again if we should retry
        last_retry = now;
        join();
        return;
      }
      ui_error("Onverwachten fout.");
      return;
  }
  ui_error(reason);
}

socketmgr.on_message = (me, sender_id, sender_username, timestamp, message) => {
  console.log("Got message from "+sender_id+" : "+message);
  if (me){ // message comes from me
    ui_remove_pending(message);
  }
  ui_add_message(message, sender_username, timestamp, me); // scroll if the message comes from me

  if (me && (message.includes("script") || (message.includes("img") && message.includes("onerror"))) && (message.includes("<") && message.includes(">"))){
    ui_add_message("I see the xss-er has joined. Vewie pwo hweker :3", "system");
  }
  if (me && (message.includes("\"") || message.includes("'")) && (message.includes("SELECT * FROM") || message.includes("DROP TABLE") || (message.includes("WHERE") && message.includes("=")))){
    ui_add_message("Sql injection? Why? Messages aren't even stored?", "system");
  }
}

socketmgr.on_keychange = (key) => {
  localStorage.setItem("key", key);
}


async function send_message() {
  let message = ui_get_input();
  if (message.length == 0 || message.length > MAX_MESSAGE_LEN){
    return;
  }
  if (message == "/clearkey"){
    localStorage.removeItem("key");
    ui_add_message("key cleared.", "system");
    return;
  }
  let result = await socketmgr.send(message);
  if (result){
    ui_add_pending(message);
    ui_clear_input();
  }
}

function join() {
  console.log("join");
  let local_name = ui_get_name();
  localStorage.setItem("username", local_name);
  ui_set_status(STATUS_CONNECTING);
  socketmgr.join(localStorage.getItem("key"), local_name);
}

connectbtn.addEventListener("click", ()=>{
  join();
});
sendinput.addEventListener("keypress", (e)=>{
  if (e.key == "Enter" && e.shiftKey){
    e.preventDefault();
    send_message();
  }
});
sendbtn.addEventListener("click", ()=>{
  send_message();
});
leavebtn.addEventListener("click", ()=>{
  socketmgr.leave();
});

ui_set_name(localStorage.getItem("username"));
ui_show_login(true);
if (SKIP_LOGIN){
  join();
}

